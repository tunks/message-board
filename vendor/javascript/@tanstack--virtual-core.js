function memo(t,e,s){let n=s.initialDeps??[];let i;return()=>{var o,l,r,h;let a;s.key&&((o=s.debug)==null?void 0:o.call(s))&&(a=Date.now());const c=t();const d=c.length!==n.length||c.some(((t,e)=>n[e]!==t));if(!d)return i;n=c;let u;s.key&&((l=s.debug)==null?void 0:l.call(s))&&(u=Date.now());i=e(...c);if(s.key&&((r=s.debug)==null?void 0:r.call(s))){const t=Math.round(100*(Date.now()-a))/100;const e=Math.round(100*(Date.now()-u))/100;const n=e/16;const pad=(t,e)=>{t=String(t);while(t.length<e)t=" "+t;return t};console.info(`%câ± ${pad(e,5)} /${pad(t,5)} ms`,`\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0,Math.min(120-120*n,120))}deg 100% 31%);`,s==null?void 0:s.key)}(h=s==null?void 0:s.onChange)==null?void 0:h.call(s,i);return i}}function notUndefined(t,e){if(t===void 0)throw new Error("Unexpected undefined"+(e?`: ${e}`:""));return t}const approxEqual=(t,e)=>Math.abs(t-e)<1;const debounce=(t,e,s)=>{let n;return function(...i){t.clearTimeout(n);n=t.setTimeout((()=>e.apply(this,i)),s)}};const defaultKeyExtractor=t=>t;const defaultRangeExtractor=t=>{const e=Math.max(t.startIndex-t.overscan,0);const s=Math.min(t.endIndex+t.overscan,t.count-1);const n=[];for(let t=e;t<=s;t++)n.push(t);return n};const observeElementRect=(t,e)=>{const s=t.scrollElement;if(!s)return;const n=t.targetWindow;if(!n)return;const handler=t=>{const{width:s,height:n}=t;e({width:Math.round(s),height:Math.round(n)})};handler(s.getBoundingClientRect());if(!n.ResizeObserver)return()=>{};const i=new n.ResizeObserver((t=>{const e=t[0];if(e==null?void 0:e.borderBoxSize){const t=e.borderBoxSize[0];if(t){handler({width:t.inlineSize,height:t.blockSize});return}}handler(s.getBoundingClientRect())}));i.observe(s,{box:"border-box"});return()=>{i.unobserve(s)}};const t={passive:true};const observeWindowRect=(e,s)=>{const n=e.scrollElement;if(!n)return;const handler=()=>{s({width:n.innerWidth,height:n.innerHeight})};handler();n.addEventListener("resize",handler,t);return()=>{n.removeEventListener("resize",handler)}};const e=typeof window=="undefined"||"onscrollend"in window;const observeElementOffset=(s,n)=>{const i=s.scrollElement;if(!i)return;const o=s.targetWindow;if(!o)return;let l=0;const r=e?()=>{}:debounce(o,(()=>{n(l,false)}),s.options.isScrollingResetDelay);const createHandler=t=>()=>{const{horizontal:e,isRtl:o}=s.options;l=e?i.scrollLeft*(o?-1:1):i.scrollTop;r();n(l,t)};const h=createHandler(true);const a=createHandler(false);a();i.addEventListener("scroll",h,t);i.addEventListener("scrollend",a,t);return()=>{i.removeEventListener("scroll",h);i.removeEventListener("scrollend",a)}};const observeWindowOffset=(s,n)=>{const i=s.scrollElement;if(!i)return;const o=s.targetWindow;if(!o)return;let l=0;const r=e?()=>{}:debounce(o,(()=>{n(l,false)}),s.options.isScrollingResetDelay);const createHandler=t=>()=>{l=i[s.options.horizontal?"scrollX":"scrollY"];r();n(l,t)};const h=createHandler(true);const a=createHandler(false);a();i.addEventListener("scroll",h,t);i.addEventListener("scrollend",a,t);return()=>{i.removeEventListener("scroll",h);i.removeEventListener("scrollend",a)}};const measureElement=(t,e,s)=>{if(e==null?void 0:e.borderBoxSize){const t=e.borderBoxSize[0];if(t){const e=Math.round(t[s.options.horizontal?"inlineSize":"blockSize"]);return e}}return Math.round(t.getBoundingClientRect()[s.options.horizontal?"width":"height"])};const windowScroll=(t,{adjustments:e=0,behavior:s},n)=>{var i,o;const l=t+e;(o=(i=n.scrollElement)==null?void 0:i.scrollTo)==null?void 0:o.call(i,{[n.options.horizontal?"left":"top"]:l,behavior:s})};const elementScroll=(t,{adjustments:e=0,behavior:s},n)=>{var i,o;const l=t+e;(o=(i=n.scrollElement)==null?void 0:i.scrollTo)==null?void 0:o.call(i,{[n.options.horizontal?"left":"top"]:l,behavior:s})};class Virtualizer{constructor(t){this.unsubs=[];this.scrollElement=null;this.targetWindow=null;this.isScrolling=false;this.scrollToIndexTimeoutId=null;this.measurementsCache=[];this.itemSizeCache=new Map;this.pendingMeasuredCacheIndexes=[];this.scrollRect=null;this.scrollOffset=null;this.scrollDirection=null;this.scrollAdjustments=0;this.elementsCache=new Map;this.observer=(()=>{let t=null;const get=()=>t||(this.targetWindow&&this.targetWindow.ResizeObserver?t=new this.targetWindow.ResizeObserver((t=>{t.forEach((t=>{this._measureElement(t.target,t)}))})):null);return{disconnect:()=>{var e;(e=get())==null?void 0:e.disconnect();t=null},observe:t=>{var e;return(e=get())==null?void 0:e.observe(t,{box:"border-box"})},unobserve:t=>{var e;return(e=get())==null?void 0:e.unobserve(t)}}})();this.range=null;this.setOptions=t=>{Object.entries(t).forEach((([e,s])=>{typeof s==="undefined"&&delete t[e]}));this.options={debug:false,initialOffset:0,overscan:1,paddingStart:0,paddingEnd:0,scrollPaddingStart:0,scrollPaddingEnd:0,horizontal:false,getItemKey:defaultKeyExtractor,rangeExtractor:defaultRangeExtractor,onChange:()=>{},measureElement:measureElement,initialRect:{width:0,height:0},scrollMargin:0,gap:0,indexAttribute:"data-index",initialMeasurementsCache:[],lanes:1,isScrollingResetDelay:150,enabled:true,isRtl:false,...t}};this.notify=t=>{var e,s;(s=(e=this.options).onChange)==null?void 0:s.call(e,this,t)};this.maybeNotify=memo((()=>{this.calculateRange();return[this.isScrolling,this.range?this.range.startIndex:null,this.range?this.range.endIndex:null]}),(t=>{this.notify(t)}),{key:process.env.NODE_ENV!=="production"&&"maybeNotify",debug:()=>this.options.debug,initialDeps:[this.isScrolling,this.range?this.range.startIndex:null,this.range?this.range.endIndex:null]});this.cleanup=()=>{this.unsubs.filter(Boolean).forEach((t=>t()));this.unsubs=[];this.observer.disconnect();this.scrollElement=null;this.targetWindow=null};this._didMount=()=>()=>{this.cleanup()};this._willUpdate=()=>{var t;const e=this.options.enabled?this.options.getScrollElement():null;if(this.scrollElement!==e){this.cleanup();if(!e){this.maybeNotify();return}this.scrollElement=e;this.scrollElement&&"ownerDocument"in this.scrollElement?this.targetWindow=this.scrollElement.ownerDocument.defaultView:this.targetWindow=((t=this.scrollElement)==null?void 0:t.window)??null;this.elementsCache.forEach((t=>{this.observer.observe(t)}));this._scrollToOffset(this.getScrollOffset(),{adjustments:void 0,behavior:void 0});this.unsubs.push(this.options.observeElementRect(this,(t=>{this.scrollRect=t;this.maybeNotify()})));this.unsubs.push(this.options.observeElementOffset(this,((t,e)=>{this.scrollAdjustments=0;this.scrollDirection=e?this.getScrollOffset()<t?"forward":"backward":null;this.scrollOffset=t;this.isScrolling=e;this.maybeNotify()})))}};this.getSize=()=>{if(!this.options.enabled){this.scrollRect=null;return 0}this.scrollRect=this.scrollRect??this.options.initialRect;return this.scrollRect[this.options.horizontal?"width":"height"]};this.getScrollOffset=()=>{if(!this.options.enabled){this.scrollOffset=null;return 0}this.scrollOffset=this.scrollOffset??(typeof this.options.initialOffset==="function"?this.options.initialOffset():this.options.initialOffset);return this.scrollOffset};this.getFurthestMeasurement=(t,e)=>{const s=new Map;const n=new Map;for(let i=e-1;i>=0;i--){const e=t[i];if(s.has(e.lane))continue;const o=n.get(e.lane);o==null||e.end>o.end?n.set(e.lane,e):e.end<o.end&&s.set(e.lane,true);if(s.size===this.options.lanes)break}return n.size===this.options.lanes?Array.from(n.values()).sort(((t,e)=>t.end===e.end?t.index-e.index:t.end-e.end))[0]:void 0};this.getMeasurementOptions=memo((()=>[this.options.count,this.options.paddingStart,this.options.scrollMargin,this.options.getItemKey,this.options.enabled]),((t,e,s,n,i)=>{this.pendingMeasuredCacheIndexes=[];return{count:t,paddingStart:e,scrollMargin:s,getItemKey:n,enabled:i}}),{key:false});this.getMeasurements=memo((()=>[this.getMeasurementOptions(),this.itemSizeCache]),(({count:t,paddingStart:e,scrollMargin:s,getItemKey:n,enabled:i},o)=>{if(!i){this.measurementsCache=[];this.itemSizeCache.clear();return[]}if(this.measurementsCache.length===0){this.measurementsCache=this.options.initialMeasurementsCache;this.measurementsCache.forEach((t=>{this.itemSizeCache.set(t.key,t.size)}))}const l=this.pendingMeasuredCacheIndexes.length>0?Math.min(...this.pendingMeasuredCacheIndexes):0;this.pendingMeasuredCacheIndexes=[];const r=this.measurementsCache.slice(0,l);for(let i=l;i<t;i++){const t=n(i);const l=this.options.lanes===1?r[i-1]:this.getFurthestMeasurement(r,i);const h=l?l.end+this.options.gap:e+s;const a=o.get(t);const c=typeof a==="number"?a:this.options.estimateSize(i);const d=h+c;const u=l?l.lane:i%this.options.lanes;r[i]={index:i,start:h,size:c,end:d,key:t,lane:u}}this.measurementsCache=r;return r}),{key:process.env.NODE_ENV!=="production"&&"getMeasurements",debug:()=>this.options.debug});this.calculateRange=memo((()=>[this.getMeasurements(),this.getSize(),this.getScrollOffset()]),((t,e,s)=>this.range=t.length>0&&e>0?calculateRange({measurements:t,outerSize:e,scrollOffset:s}):null),{key:process.env.NODE_ENV!=="production"&&"calculateRange",debug:()=>this.options.debug});this.getIndexes=memo((()=>[this.options.rangeExtractor,this.calculateRange(),this.options.overscan,this.options.count]),((t,e,s,n)=>e===null?[]:t({startIndex:e.startIndex,endIndex:e.endIndex,overscan:s,count:n})),{key:process.env.NODE_ENV!=="production"&&"getIndexes",debug:()=>this.options.debug});this.indexFromElement=t=>{const e=this.options.indexAttribute;const s=t.getAttribute(e);if(!s){console.warn(`Missing attribute name '${e}={index}' on measured element.`);return-1}return parseInt(s,10)};this._measureElement=(t,e)=>{const s=this.indexFromElement(t);const n=this.measurementsCache[s];if(!n)return;const i=n.key;const o=this.elementsCache.get(i);if(o!==t){o&&this.observer.unobserve(o);this.observer.observe(t);this.elementsCache.set(i,t)}t.isConnected&&this.resizeItem(s,this.options.measureElement(t,e,this))};this.resizeItem=(t,e)=>{const s=this.measurementsCache[t];if(!s)return;const n=this.itemSizeCache.get(s.key)??s.size;const i=e-n;if(i!==0){if(this.shouldAdjustScrollPositionOnItemSizeChange!==void 0?this.shouldAdjustScrollPositionOnItemSizeChange(s,i,this):s.start<this.getScrollOffset()+this.scrollAdjustments){process.env.NODE_ENV!=="production"&&this.options.debug&&console.info("correction",i);this._scrollToOffset(this.getScrollOffset(),{adjustments:this.scrollAdjustments+=i,behavior:void 0})}this.pendingMeasuredCacheIndexes.push(s.index);this.itemSizeCache=new Map(this.itemSizeCache.set(s.key,e));this.notify(false)}};this.measureElement=t=>{t?this._measureElement(t,void 0):this.elementsCache.forEach(((t,e)=>{if(!t.isConnected){this.observer.unobserve(t);this.elementsCache.delete(e)}}))};this.getVirtualItems=memo((()=>[this.getIndexes(),this.getMeasurements()]),((t,e)=>{const s=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];const o=e[i];s.push(o)}return s}),{key:process.env.NODE_ENV!=="production"&&"getVirtualItems",debug:()=>this.options.debug});this.getVirtualItemForOffset=t=>{const e=this.getMeasurements();if(e.length!==0)return notUndefined(e[findNearestBinarySearch(0,e.length-1,(t=>notUndefined(e[t]).start),t)])};this.getOffsetForAlignment=(t,e)=>{const s=this.getSize();const n=this.getScrollOffset();e==="auto"&&(e=t<=n?"start":t>=n+s?"end":"start");e==="start"?t:e==="end"?t-=s:e==="center"&&(t-=s/2);const i=this.options.horizontal?"scrollWidth":"scrollHeight";const o=this.scrollElement?"document"in this.scrollElement?this.scrollElement.document.documentElement[i]:this.scrollElement[i]:0;const l=o-s;return Math.max(Math.min(l,t),0)};this.getOffsetForIndex=(t,e="auto")=>{t=Math.max(0,Math.min(t,this.options.count-1));const s=this.measurementsCache[t];if(!s)return;const n=this.getSize();const i=this.getScrollOffset();if(e==="auto")if(s.end>=i+n-this.options.scrollPaddingEnd)e="end";else{if(!(s.start<=i+this.options.scrollPaddingStart))return[i,e];e="start"}const o=e==="end"?s.end+this.options.scrollPaddingEnd:s.start-this.options.scrollPaddingStart;return[this.getOffsetForAlignment(o,e),e]};this.isDynamicMode=()=>this.elementsCache.size>0;this.cancelScrollToIndex=()=>{if(this.scrollToIndexTimeoutId!==null&&this.targetWindow){this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);this.scrollToIndexTimeoutId=null}};this.scrollToOffset=(t,{align:e="start",behavior:s}={})=>{this.cancelScrollToIndex();s==="smooth"&&this.isDynamicMode()&&console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");this._scrollToOffset(this.getOffsetForAlignment(t,e),{adjustments:void 0,behavior:s})};this.scrollToIndex=(t,{align:e="auto",behavior:s}={})=>{t=Math.max(0,Math.min(t,this.options.count-1));this.cancelScrollToIndex();s==="smooth"&&this.isDynamicMode()&&console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");const n=this.getOffsetForIndex(t,e);if(!n)return;const[i,o]=n;this._scrollToOffset(i,{adjustments:void 0,behavior:s});s!=="smooth"&&this.isDynamicMode()&&this.targetWindow&&(this.scrollToIndexTimeoutId=this.targetWindow.setTimeout((()=>{this.scrollToIndexTimeoutId=null;const e=this.elementsCache.has(this.options.getItemKey(t));if(e){const[e]=notUndefined(this.getOffsetForIndex(t,o));approxEqual(e,this.getScrollOffset())||this.scrollToIndex(t,{align:o,behavior:s})}else this.scrollToIndex(t,{align:o,behavior:s})})))};this.scrollBy=(t,{behavior:e}={})=>{this.cancelScrollToIndex();e==="smooth"&&this.isDynamicMode()&&console.warn("The `smooth` scroll behavior is not fully supported with dynamic size.");this._scrollToOffset(this.getScrollOffset()+t,{adjustments:void 0,behavior:e})};this.getTotalSize=()=>{var t;const e=this.getMeasurements();let s;s=e.length===0?this.options.paddingStart:this.options.lanes===1?((t=e[e.length-1])==null?void 0:t.end)??0:Math.max(...e.slice(-this.options.lanes).map((t=>t.end)));return Math.max(s-this.options.scrollMargin+this.options.paddingEnd,0)};this._scrollToOffset=(t,{adjustments:e,behavior:s})=>{this.options.scrollToFn(t,{behavior:s,adjustments:e},this)};this.measure=()=>{this.itemSizeCache=new Map;this.notify(false)};this.setOptions(t)}}const findNearestBinarySearch=(t,e,s,n)=>{while(t<=e){const i=(t+e)/2|0;const o=s(i);if(o<n)t=i+1;else{if(!(o>n))return i;e=i-1}}return t>0?t-1:0};function calculateRange({measurements:t,outerSize:e,scrollOffset:s}){const n=t.length-1;const getOffset=e=>t[e].start;const i=findNearestBinarySearch(0,n,getOffset,s);let o=i;while(o<n&&t[o].end<s+e)o++;return{startIndex:i,endIndex:o}}export{Virtualizer,approxEqual,debounce,defaultKeyExtractor,defaultRangeExtractor,elementScroll,measureElement,memo,notUndefined,observeElementOffset,observeElementRect,observeWindowOffset,observeWindowRect,windowScroll};

